<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    
    <base href="http://localhost:8080/"/>
    
    <meta name="description" content="Improvement on the coroutine to web component conversion function, adding reactive attributes" >
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="generator" content="Eleventy v2.0.1">
    <title>lorenzofox blog | Reactive attributes and micro tasks</title>
    <link rel="icon" href="./public/favicon.ico" />
    <link href="./public/prism-okaidia.css" rel="stylesheet">
    <link rel="stylesheet" href="./public/theme.css">
    <style>
        #logo {
            aspect-ratio: 1 / 1;
            width: 128px;
        }
    </style>
</head>
<body>
<header id="main-header">
    <a href="./"><img id="logo" src="./public/logo.webp" alt="lorenzofox's blog logo" />Home</a>
    <div class="title">
        <h1>Reactive attributes and micro tasks</h1>
        

    </div>
    
    <a rel="author" href="./about">About</a>
    
</header>
<main id="main">
    <p>In the <a href="./posts/component-as-infinite-loop">previous article</a>, we finished by providing a function to convert a coroutine into a custom element.
In this post we will iterate by adding <em>optimised</em> reactive attributes to our component definition, using the hidden gem <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide">queueMicrotask</a>.</p>
<h2>On component interfaces</h2>
<p>Custom elements let you declare observable attributes (thus limited to string values) and react to any change. This seems limiting compared to the rich data properties you have with frameworks like Vuejs, React and so on.
However, You have to keep in mind that, with these frameworks, the component models live in memory within yet another abstraction on top of the Document Object Model that the browser deals with. Custom elements can be serialised (i.e. expressed as an HTML string) just like any regular built-in element.
This implies, for example, that you don't need any specific tooling/runtime other than an HTML template engine to create these components as part of an HTML fragment on the server side.</p>
<p>Anyway, we will see later how to define rich reactive properties. But again, these properties would require a programmatic access to the related DOM node rather than a simple declarative approach.</p>

</main>
</body>
</html>
