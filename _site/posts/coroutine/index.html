<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<!--    <meta name="description" content="" >-->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>lorenzofox blog | Coroutines</title>
    <link rel="stylesheet" href="/public/theme.css">
</head>
<body>
<main>
    <h1>Coroutines</h1>
    <p>A <a href="https://en.wikipedia.org/wiki/Coroutine">coroutine</a> is a function whose execution can be suspended and resumed, possibly passing some data. They happen to be useful for implementing various patterns involving cooperation between different tasks/functions such as asynchronous flows for example.</p>
<h2>In javascript</h2>
<p>In Javascript you can implement (sort of) coroutines using generator functions. You may have already used generator functions to implement iterators and sequences.</p>
<pre><code class="language-Javascript">function *integers(){
    let n = 0;
    while(true){
        yield ++n;
    }
}

const sequence = integers();

console.log(sequence.next().value); // &gt; 1
console.log(sequence.next().value); // &gt; 2
console.log(sequence.next().value); // &gt; 3
console.log(sequence.next().value); // &gt; 4
</code></pre>
<p>The <code>while(true)</code> is interesting (and totally fine) here because it testifies that the generator is being evaluated lazily. What actually happens when you call the <code>next</code> function is that the generator is executed until the next <code>yield</code> statement. Whatever the result of the expression on the right side of the <code>yield</code> is, it becomes the <code>value</code> of the iterator result and the generator function is paused.</p>
<p>What we don't usually know is that you can pass data to the <code>next</code> function when you resume the execution of the routine, which has the effect of assigning that data to any variable on the &quot;left&quot; side of the statement:</p>
<pre><code class="language-Javascript">function *generator() {
    while(true){
        const action = yield;
        console.log(action)
    }
}

const routine = generator();
routine.next();
routine.next('increment'); // &gt; 'increment'
routine.next('go-left'); // &gt; 'go-left
</code></pre>
<p>The first call to <code>next</code> obviously cannot receive any data as the routine has not been paused yet.</p>
<h2>Bidirectional example</h2>
<p>Although you will often use the generator as either a producer or a sink of data, you can use it in both directions at the same time. Beware, it can be confusing and complex to manage, but it comes in handy to implement some patterns.</p>
<p>See the following &quot;Redux&quot; like state machine:</p>
<pre><code class="language-Javascript">function* EventLoop({reducer, state}) {
    while (true) {
        const action = yield state; // wow !
        state = reducer(state, action);
    }
}

const createEventLoop = ({reducer, state}) =&gt; {
    const eventLoop = EventLoop({reducer, state});
    eventLoop.next();
    return (action) =&gt; eventLoop.next(action).value;
};

const createSubscribable = () =&gt; {
    const eventName = 'state-changed';
    const eventTarget = new EventTarget();
    
    const notify = () =&gt; eventTarget.dispatchEvent(new CustomEvent(eventName));
    const subscribe = (listener) =&gt; {
        eventTarget.addEventListener(eventName, listener);
        return () =&gt; unsubscribe(listener);
    };
    const unsubscribe = (listener) =&gt;
        eventTarget.removeEventListener(eventName, listener);

    return {
        unsubscribe,
        subscribe,
        notify
    };
};

const createStore = ({reducer, initialState}) =&gt; {
    let state = initialState;

    const {notify, ...subscribable} = createSubscribable();

    const dispatch = createEventLoop({reducer, state});

    return {
        ...subscribable,
        getState() {
            return structuredClone(state);
        },
        dispatch(action) {
            state = dispatch(action);
            notify();
        }
    };
};

const store = createStore(
    {
        reducer: (state, action) =&gt; {
            switch (action.type) {
                case 'increment':
                    return {
                        ...state,
                        count: state.count + 1,
                    };
                case 'decrement':
                    return {
                        ...state,
                        count: state.count - 1,
                    };
                default:
                    return state;
            }
        },
        initialState: {
            count: 0,
        }
    }
);

store.subscribe(() =&gt; console.log(store.getState()));

store.dispatch({
    type: 'increment'
}); // log { count: 1 }
store.dispatch({
    type: 'increment'
}); // log { count: 2 }
store.dispatch({
    type: 'decrement'
}); // log { count: 1 }
</code></pre>
<p>The interesting part for us is the <code>EventLoop</code> routine which, when paused, yields the current state and, when resumed, receives the next action to process.
The <code>createEventLoop</code> function hides the fact that we are using a coroutine to implement the state machine, making it a detail of the implementation. However, thanks to the coroutine, the overall solution remains concise and quite simple.</p>
<h2>Async flow example</h2>
<p>In the previous example we saw how we could model an event loop with a coroutine. In the following example, we will see a different kind of &quot;cooperative multitasking&quot;, building an asynchronous workflow with the same semantics as the regular <code>async</code> function ( with the <code>await</code> keyword).</p>
<pre><code class="language-Javascript">const co = (genFn) =&gt; (...args) =&gt; {
  const gen = genFn(...args);
    
  // no data to next as the routine has not been paused yet
  return next();

  function next(data) {
    const { value, done } = gen.next(data);

    if (done) {
      return value;
    }

    // non promise value
    if (value.then === undefined) {
      return next(value);
    }

    // we resume the routine assigning the resolved value to &quot;yield&quot;  
    return value.then(next);
  }

};

const fn = co(function* (arg) {
  let value = yield asyncTask(arg);
  value = yield otherAsyncTask(value);
  return value;
});

fn(42).then(console.log);
</code></pre>
<p>The idea behind is quite simple: our main asynchronous function is paused whenever it delegates a task to another function. If that function is itself asynchronous, we wait for the pending Promise to resolve and then resume the main routine with the resolved value.
This is very similar to the <code>async</code> function, except that you replace the built-in <code>await</code> keyword with <code>yield</code>.</p>
<h2>Going further</h2>
<p>It is important to note that a generator has more than just the <code>next</code> function. <code>return</code> and <code>throw</code> can indeed help to create different flows.
In a future article, we will see how we can use a coroutine to model a UI component as an event loop, where each iteration represents a content rendering.</p>

</main>
</body>
</html>
