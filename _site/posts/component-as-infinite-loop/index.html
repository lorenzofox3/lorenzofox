<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<!--    <meta name="description" content="" >-->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>lorenzofox blog | </title>
    <link rel="stylesheet" href="/public/theme.css">
</head>
<body>
<main>
    <h1></h1>
    <h1>Coroutines and web components</h1>
<p>In the <a href="./coroutine">previous article</a> we learned what coroutines are and saw some patterns they can help implement.
In this article, we will see how coroutines can be used to model web components in a different way, and why you might like it.</p>
<h2>Rendering loop</h2>
<p>Among other things, coroutines have a few properties that we will use in this short essay:</p>
<ul>
<li>They are primarily <strong>functions</strong> and can benefit from the whole functional arsenal of Javascript (composition, higher order function, delegation, etc.).</li>
<li>They are <strong>stateful</strong>.</li>
<li>You can inject pretty much any kind of data when they are paused. For example, an infinite loop within the body of the routine can be considered as a public API function.</li>
<li>You cannot, by design, call the <code>next</code> function concurrently.</li>
</ul>
<h2>Introduction example</h2>
<p>Consider the following generator:</p>
<pre><code class="language-Javascript">function* someComponent({$host}) {
    while (true) {
        const {content = ''} = yield;
        $host.textContent = content;
    }
}
</code></pre>
<p>It takes a <code>$host</code> DOM element and has a rendering loop. You can wrap this generator with a function that produces a <code>render</code> function:</p>
<pre><code class="language-Javascript">const createComponent = (generator) =&gt; ({$host}) =&gt; {
    const gen = generator({$host});
    gen.next(); // we initiate the component by entering inside the rendering loop
    return (state = {}) =&gt; gen.next(state);
};

const HelloWorldComponent = createComponent(function* ({$host}) {
    while (true) {
        const {name = ''} = yield;
        $host.textContent = `hello ${name}`;
    }
});

// div is some DOM element
const render = HelloWorldComponent({
    $host: div
});

render({name: 'Laurent'});
render({name: 'Bernadette'});
</code></pre>
<h2>The power of functions</h2>
<p>For now, the rendering loop is a piece of imperative code, but it can use any rendering library you want (react and so on).
The first point above says that functions (and therefore coroutines) are very versatile in Javascript. We could easily go back to a known paradigm if we wanted to. For example, we use <a href="./todo">lit-html</a> to have a declarative view instead of a bunch of imperative code:</p>
<pre><code class="language-Javascript">import {render, html} from 'lit-element';

const HelloWorldComponent = createComponent(function* ({$host}) {
    while (true) {
        const {name=''} = yield
        const template = html`&lt;p&gt;hello ${name}&lt;/p&gt;`;
        render($host, template);
    }
});
</code></pre>
<p>you can draw the template into a function:</p>
<pre><code class="language-Javascript">import {html} from 'lit-element';

const template = ({name = ''} = {}) =&gt; html`&lt;p&gt;hello ${name}&lt;/p&gt;`;
</code></pre>
<p>And compose with a new higher order function:</p>
<pre><code class="language-Javascript">import {render} from 'lit-element';

const withView = (templateFn) =&gt; function* ({$host}) {
    while (true) {
        render($host, templateFn(yield));
    }
};

const HelloWorldComponent = createComponent(withView(template));
</code></pre>
<p>All right, our component is now a simple function of the state (<code>({name}) =&gt; html\`&lt;p&gt;hello ${name}&lt;/p&gt;\`</code>), and we are on familiar ground.</p>
<h2>Maintaining a state</h2>
<p>Having an infinite rendering loop to model our component can actually be more interesting than it seems at first: you can have a state in the closure of that loop.</p>
<p>If we first modify the higher-level <code>createComponent</code> function a little to bind the <code>render</code> function to the host element:</p>
<pre><code class="language-Javascript">const createComponent = (generator) =&gt; ({$host}) =&gt; {
    const gen = generator({$host});
    gen.next();
    $host.render = (state = {}) =&gt; gen.next(state);
    return $host;
};
</code></pre>
<p>We can now make the component trigger its own rendering:</p>
<pre><code class="language-Javascript">const CountClick = createComponent(function *({$host}){
   let clickCount = 0;
   
   $host.addEventListener('click', () =&gt; {
       clickCount+=1;
       $host.render();
   });
   
   while(true) {
       $host.textContent = `I have been clicked ${clickCount} time(s)`
       yield;
   }
});
</code></pre>
<p>In frameworks like React, where you only have access to the equivalent of what is inside the loop, you rely on the framework extension points (the hooks in the case of React) to build this sort of mechanism, and have very little control over rendering scheduling.</p>
<h2>More HOF function to reduce the coupling.</h2>
<p>The component embeds its view and some logic at the same time. Again, we can easily decouple them so that we can reuse either the view or the logic:
All we need to do is take advantage of the third property of coroutines mentioned in the introduction, and a simple delegation mechanism inherent to generators: <code>yield*</code>.</p>
<pre><code class="language-Javascript">const countClickable = (view) =&gt; function *({$host}) {
    let clickCount = 0;

    $host.addEventListener('click', () =&gt; {
        clickCount+=1;
        $host.render({count: clickCount});
    });
    
    yield* view({$host}); 
}
</code></pre>
<p>This type of mixin is responsible for holding the state and triggering the rendering of any <em>view</em>. Rendering is left to the view thanks to <strong>delegation</strong>, while the state is passed whenever the view coroutine is paused and requires a new render:</p>
<pre><code class="language-Javascript">const CountClick = createComponent(countClickable(function* ({$host}) {
    while (true) {
        const {count = 0} = yield;
        $host.textContent = `I have been clicked ${count} time(s)`;
    }
}));
</code></pre>
<p>Neat ! You can now use the &quot;clickable&quot; behaviour independently, on different views. In the same way, you can plug the view into a different controller logic, as long as it passes the expected data interface (<code>{ count: number | string}</code>): note how the data comes from the <code>yield</code> assignation.</p>
<p>We will see more patterns like this in future articles.</p>
<h2>Web components and lifecycle mapping</h2>
<p>So far we have designed our component to be a function of the host. We can go further and ensure that the rendering routine is actually private to the host, so that the rendering code is encapsulated inside along with any potential behaviour enhancements (the <code>countClickable</code> mixin for example), while both remain reusable.</p>
<p>Let's look at another way of modelling <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements">custom elements</a>. To enhance your HTML document, you can teach the browser new ones using its registry and the <code>define</code> method.</p>
<pre><code class="language-Javascript">customElements.define('hello-world', class extends HTMLElement {
    connectedCallback() {
        this.textContent = `hello ${this.getAttribute('name')}`
    }
}) // (define takes a third optional argument we won't consider for the moment)
</code></pre>
<p>And then use the <code>hello-world</code> tag in the markup like any other regular HTML tag.</p>
<pre><code class="language-html">&lt;hello-world name=&quot;Laurent&quot;&gt;&lt;/hello-world&gt;
</code></pre>
<p>Instead of using a class that extends the <code>HTMLElement</code> class (or any other valid built-in element class), we want the second argument to be a generator function. This means our custom <code>define</code> would need to turn the generator into a class.</p>
<pre><code class="language-javascript">const define = (tag, gen) =&gt; {
    customElements.define(tag, class extends HTMLElement {
        #loop;

        constructor() {
            super();
            this.#loop = gen.bind(this)({
                $host: this
            });
            this.render = this.render.bind(this);
            this.#loop.next();
        }

        connectedCallback() {
            this.render();
        }

        render(state = {}) {
            this.#loop.next(state);
        }

    });
};

define('hello-world', function* ({$host}) {
    while(true) {
        yield;
        $host.textContent = `hello ${$host.getAttribute('name')}`
    }
});
</code></pre>
<p>Using a class expression, we create the custom element class on the fly. The <code>#loop</code> rendering routine is instantiated inside the constructor and advanced to its first <code>yield</code> point. Note that we pass the host as a parameter to the routine, although the routine is specifically bound to the host so that we could just use <code>this</code> inside the generator to refer to the host. This is a personal preference as I find the use of <code>this</code> in Javascript very error-prone.</p>
<p>When the <code>connectedCallback</code> is called (this happens when the component is mounted into the DOM). We call <code>next</code> again, which in our previous example corresponds to the first iteration of the loop. Then, whenever the component needs to be rendered (when <code>render</code> is called) again, we continue the loop.</p>
<p>This is very interesting because we are able to match the different component lifecycles to a location within the generator function:</p>
<pre><code class="language-Javascript">function* comp({$host}) {

    console.log('I am being instantiated');

    yield;

    console.log('Iam being mounted');
    $host.textContent = 'I have just been mounted';

    yield;

    while (true) {
        console.log('I am being rendered');
        $host.textContent = `hello ${$host.getAttribute('name')}`;
        yield 'I have been rendered';
    }
}
</code></pre>
<p>Yet, one important lifecycle remains to be implemented. When the component is unmounted, the <code>disconnectedCallbak</code> of the class definition is normally called, allowing us to run cleanup code and avoid memory leaks for example.</p>
<p>In the generator we can force the exit of the loop into a <code>finally</code> clause. This is as simple as calling the loop's <code>return</code> function instead of the usual <code>next</code>.</p>
<p>Altogether:</p>
<pre><code class="language-javascript">const define = (tag, gen) =&gt; {
    customElements.define(tag, class extends HTMLElement {
        #loop;

        constructor() {
            super();
            this.#loop = gen.bind(this)({
                $host: this
            });
            this.render = this.render.bind(this);
            this.#loop.next();
        }

        connectedCallback() {
            this.render();
        }
        
        disconnectedCallback() {
            this.#loop.return();
        }

        render(state = {}) {
            this.#loop.next(state);
        }

    });
};

function* comp({$host}) {

    console.log('I am being instantiated');

    yield;

    console.log('Iam being mounted');
    $host.textContent = 'I have just been mounted'

    yield;

    try {
        while (true) {
            console.log('I am being rendered');
            $host.textContent = `hello ${$host.getAttribute('name')}`;
            yield;
        }
    } finally {
        console.log('cleanup here !!!');
    }
}
</code></pre>
<p>This &quot;linear&quot; representation of the component and its lifetime makes things easier to reason about: there are no surprises when a callback or a hook is called, everything is read from top to bottom!</p>
<h2>Concurrent updates</h2>
<p>Before we conclude, we can illustrate the fourth point mentioned in the introduction: if you try to advance a generator function while it is already advancing, you will get an error. In the component world, this means that concurrent rendering is impossible by design!</p>
<p>This code:</p>
<pre><code class="language-javascript">function* comp({$host}) {
    while (true) {
        console.log('I am being rendered');

        $host.render(); // yet I try to render ...

        $host.textContent = `hello ${$host.getAttribute('name')}`;
        yield;
    }
}
</code></pre>
<p>will trigger an error <code>Uncaught TypeError: already executing generator</code>.</p>
<h2>conclusion</h2>
<p>We have seen throughout this article that the functional nature of a generator combined with its intrinsic properties can be useful to build a very flexible and simple abstraction of UI component, with the ability to split behaviour and view into reusable bits, to maintain internal state or to have at reach all component lifecycles in the same place.</p>
<p>In the next article, we will see how we can further improve and optimise our generator-to-class conversion.</p>

</main>
</body>
</html>
